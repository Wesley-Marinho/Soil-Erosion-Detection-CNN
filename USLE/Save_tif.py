from osgeo import gdal, osr
import rasterio
import numpy as np
from scipy.ndimage import zoom
import geopandas as gpd
from rasterio.mask import mask
from PIL import Image
import numpy as np
import netCDF4 as nc
from rasterio.transform import from_origin


def get_tif_gt(tif_add: str) -> tuple:
    """
    Open a GeoTIFF file and retrieve its geotransform.

    Args:
        tif_add (str): Path to the GeoTIFF file.

    Returns:
        tuple: The geotransform of the GeoTIFF file.

    Raises:
        ValueError: If the input file is not a valid GeoTIFF.

    """
    data = gdal.Open(tif_add)

    if data is None:
        raise ValueError(f"{tif_add} is not a valid GeoTIFF file.")

    gt = data.GetGeoTransform()

    return gt


def create_tif(
    tif_add: str, gt: tuple, tif_matrix: np.ndarray, no_data: float = 0, srs: int = 4674
):
    """
    Create a GeoTIFF file from a NumPy array.

    Args:
        tif_add (str): Path to the output GeoTIFF file.
        gt (tuple): The geotransform of the output GeoTIFF file.
        tif_matrix (np.ndarray): The NumPy array to be saved as a GeoTIFF.
        no_data (float, optional): The no data value of the output GeoTIFF.
            Defaults to 0.
        srs (int, optional): The spatial reference system of the output GeoTIFF.
            Defaults to 4674 (WGS 84 / UTM zone 46N).

    Raises:
        ValueError: If the input GeoTIFF path is not a valid file path.

    """
    Y, X = tif_matrix.shape

    driver = gdal.GetDriverByName("GTiff")
    outRaster = driver.Create(tif_add, X, Y, 1, gdal.GDT_Float32)
    outRaster.SetGeoTransform(gt)
    outBand = outRaster.GetRasterBand(1)
    outBand.SetNoDataValue(no_data)
    outRasterSRS = osr.SpatialReference()
    outRasterSRS.ImportFromEPSG(srs)
    outRaster.SetProjection(outRasterSRS.ExportToWkt())
    outBand.WriteArray(tif_matrix)
    outBand.FlushCache()

    outRaster = None
    outBand = None
    outRasterSRS = None
    driver = None


def save_tif(destination: str, geo_path: str, tif_array: np.ndarray):
    """
    Save a NumPy array as a GeoTIFF file.

    Args:
        destination (str): Path to the output GeoTIFF file.
        geo_path (str): Path to the input GeoTIFF file.
        tif_array (np.ndarray): The NumPy array to be saved as a GeoTIFF.

    Raises:
        ValueError: If the input GeoTIFF path is not a valid file path.

    """
    gt = get_tif_gt(geo_path)
    create_tif(destination, gt, tif_array)
    print("Arquivo salvo")


def resize(standard: np.ndarray, origem: np.ndarray) -> np.ndarray:
    """
    Resizes an array to a specified shape while maintaining the aspect ratio.

    Args:
        standard (np.ndarray): The desired output shape.
        origem (np.ndarray): The array to be resized.

    Returns:
        np.ndarray: The resized array.

    Raises:
        ValueError: If the input arrays have incompatible shapes.

    """

    resized = zoom(origem, np.array(standard.shape) / np.array(origem.shape), order=1)

    return resized


def save_to_netcdf(A_reclassificado_list, output_file, color_map):
    # Supondo que A_reclassificado_list seja uma lista de arrays 2D
    num_time_steps = len(A_reclassificado_list)
    rows, cols = A_reclassificado_list[0].shape

    # Cria um arquivo NetCDF
    dataset = nc.Dataset(output_file, "w", format="NETCDF4")

    # Cria dimensões
    dataset.createDimension("time", num_time_steps)
    dataset.createDimension("lat", rows)
    dataset.createDimension("lon", cols)

    # Cria variáveis
    times = dataset.createVariable("time", "f4", ("time",))
    latitudes = dataset.createVariable("lat", "f4", ("lat",))
    longitudes = dataset.createVariable("lon", "f4", ("lon",))
    data = dataset.createVariable(
        "data",
        "i4",
        (
            "time",
            "lat",
            "lon",
        ),
    )

    # Adiciona atributos
    dataset.description = "Reclassified data with color mapping"
    dataset.history = "Created " + time.ctime(time.time())
    dataset.source = "Generated by calc_USLE function"

    latitudes.units = "degrees_north"
    longitudes.units = "degrees_east"
    times.units = "time steps"

    # Preenche as variáveis de latitude e longitude
    latitudes[:] = np.linspace(-90, 90, rows)
    longitudes[:] = np.linspace(-180, 180, cols)
    times[:] = np.arange(num_time_steps)

    # Preenche a variável de dados
    for i, A_reclassificado in enumerate(A_reclassificado_list):
        data[i, :, :] = A_reclassificado

    # Adiciona o mapa de cores como um atributo
    color_map_array = np.array([color_map[key] for key in sorted(color_map.keys())])
    color_map_var = dataset.createVariable("color_map", "i4", ("class", "rgb"))
    color_map_var[:] = color_map_array

    # Fecha o arquivo NetCDF
    dataset.close()

    print(f"Arquivo NetCDF salvo em {output_file}")
